// This file is part of the Loobee package.
//
// (c) Andrey Savitsky <contact@qroc.pro>
//
// For the full copyright and license information, please view the LICENSE
// file that was distributed with this source code.

%{
#
timeUnits = [
    # name,       nanoseconds,    detailed
    ('nanoseconds',            1, None                           ),
    ('microseconds',        1000, {'nanoseconds': 1000}          ),
    ('milliseconds',     1000000, {'nanoseconds': 1000000}       ),
    ('seconds',       1000000000, {'nanoseconds': 1000000000}    ),
    ('minutes',      60000000000, {'seconds': 60}                ),
    ('hours',      3600000000000, {'seconds': 3600}              ),
    ('days',      86400000000000, {'seconds': 86400}             ),
    ('weeks',    604800000000000, {'days': 7}                    ),
    ('months',  2629746000000000, {'days': 30, 'seconds': 37746} ),
    ('years',  31556952000000000, {'days': 365, 'seconds': 20952}),
]

#
timeUnitsInfo = {
    'nanoseconds': 'Is a minimal unit.',
    'months': 'This value exactly 1/12 of a `Duration.years` (is equal to 30.436875 days).',
    'years': 'This value is the average length of a Gregorian year (is equal to 365.2425 days).',
}

#
def getUnit(name):
    for timeUnit in timeUnits:
        if timeUnit[0] == name:
            return timeUnit
    raise RuntimeError

#
def detailedToSwiftFormat(detailed):
    from collections import OrderedDict
    ordered = OrderedDict(sorted(detailed.items(), key=lambda t: getUnit(t[0])[1], reverse=True))
    return ' + '.join('.{}({})'.format(key, value) for key, value in ordered.items())

#
def generateOperationCases(targetNanoseconds):
    cases = {'multipliedInt': [], 'multipliedFloat': [], 'dividedInt': [], 'dividedFloat': [], 'copy': []}

    for name, nanoseconds, detailed in timeUnits:
        if targetNanoseconds > nanoseconds:
            ratio = float(targetNanoseconds) / nanoseconds
            if ratio == int(ratio):
                cases['dividedInt'].append((nanoseconds, int(ratio)))
            else:
                cases['dividedFloat'].append((nanoseconds, ratio))
        elif targetNanoseconds < nanoseconds:
            ratio = float(nanoseconds) / targetNanoseconds
            if ratio == int(ratio):
                cases['multipliedInt'].append((nanoseconds, int(ratio)))
            else:
                cases['multipliedFloat'].append((nanoseconds, ratio))
        elif targetNanoseconds == nanoseconds:
            cases['copy'].append((nanoseconds, 1))

    return {k:v for k,v in cases.items() if len(v)}
}%
/// A duration represents of a span of time, defined as some time unit.
public struct Duration {
    /// Returns value of current time unit.
    public let count: Int64

    /// The ratio of the current unit to nanoseconds.
    @usableFromInline internal let ratio: Int64

    ///
    @usableFromInline
    @inline(__always)
    internal init(count: Int64, ratio: Int64) {
        self.count = count
        self.ratio = ratio
    }

    % for index, (name, nanoseconds, detailed) in enumerate(timeUnits):
    /// Represents ${name}. ${timeUnitsInfo.get(name)}
    % if detailed is not None:
    ///
    ///     .${name}(1) == ${detailedToSwiftFormat(detailed)}
    ///
    % end
    public static func ${name}(_ count: Int64) -> Duration {
        return .init(count: count, ratio: ${nanoseconds})
    }
    % if index != len(timeUnits) - 1:

    % end
    % end
}

public extension Duration {
    % for index, (name, nanoseconds, detailed) in enumerate(timeUnits):
    /// Casts current time unit to ${name}.
    % if index != 0:
    %{ prevTimeUnit = timeUnits[index - 1] }%
    ///
    /// Conversion with precision loss. For example:
    ///
    ///     .${prevTimeUnit[0]}(${nanoseconds / prevTimeUnit[1] * 2 - 1}).${name} // .${name}(1)
    ///
    % end
    /// Can return `nil` if new value is overflow.
    var ${name}: Duration? {
        %{ cases = generateOperationCases(nanoseconds) }%
        % if len(cases):
        switch self.ratio {
        % for key, ratios in cases.items():
        % for (case, ratio) in ratios:
        case ${case}:
            % if key == 'dividedInt':
                return .${name}(self.count / ${ratio})
            % elif key == 'dividedFloat':
                return .${name}(Int64(Double(self.count) / ${ratio}))
            % elif key == 'multipliedInt':
                let (${name}, overflow) = self.count.multipliedReportingOverflow(by: ${ratio})
                return _slowPath(overflow) ? nil : .${name}(${name})
            % elif key == 'multipliedFloat':
                let count = Double(self.count) * ${ratio}
                return _slowPath(count > Double(Int64.max)) ? nil : .${name}(Int64(count))
            % elif key == 'copy':
                return self
            % end
        % end
        % end
        default:
            let unreachable = { unsafeBitCast((), to: Never.self) }
            unreachable()
        }
        % else:
        return nil
        % end
    }
    % if index != len(timeUnits) - 1:

    % end
    % end
}
